unit Test_FIToolkit.Logger.Impl;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  System.Classes, System.Rtti, System.TypInfo,
  FIToolkit.Logger.Intf, FIToolkit.Logger.Impl, FIToolkit.Logger.Types,
  TestUtils;

type

  { Testing helpers }

  TTestTextOutput = class (TPlainTextOutput)
    strict private
      FLastWrittenLine : String;
      FWrittenLinesCount : Integer;
    strict protected
      procedure WriteLine(const S : String); override;
    public
      property LastWrittenLine : String read FLastWrittenLine;
      property WrittenLinesCount : Integer read FWrittenLinesCount;
  end;

  TMethodHolderObj = class abstract (TPersistent)
    published
      function  FuncMethod(const StrParam : String; IntParam : Integer;
        out ObjParam : TObject) : TTypeKind; virtual; abstract;
      procedure ProcMethod(const StrParam : String; IntParam : Integer;
        out ObjParam : TObject); virtual; abstract;
  end;

  TMethodHolderRec = record
    public
      function  FuncMethod(const StrParam : String; IntParam : Integer; out ObjParam : TObject) : TTypeKind;
      procedure ProcMethod(const StrParam : String; IntParam : Integer; out ObjParam : TObject);
  end;

  { SUT }

  // Test methods for class TLogger

  TestTLogger = class (TInterfaceTestCase<ILogger>)
  strict private
    FOutput : TTestTextOutput;
  protected
    procedure DoSetUp; override;
    procedure DoTearDown; override;
    function  MakeSUT : ILogger; override;
  published
    procedure TestAddOutput;
    procedure TestAllowedItems;
    procedure TestEnabled;
    procedure TestEnterSection;
    procedure TestEnterSection1;
    procedure TestEnterSectionFmt;
    procedure TestEnterSectionVal;
    procedure TestLeaveSection;
    procedure TestLeaveSection1;
    procedure TestLeaveSectionFmt;
    procedure TestLeaveSectionVal;
    procedure TestEnterMethod;
    procedure TestEnterMethod1;
    procedure TestLeaveMethod;
    procedure TestLeaveMethod1;
    procedure TestLog;
    procedure TestLog1;
    procedure TestLogFmt;
    procedure TestLogVal;
    procedure TestDebug;
    procedure TestDebug1;
    procedure TestDebugFmt;
    procedure TestDebugVal;
    procedure TestInfo;
    procedure TestInfo1;
    procedure TestInfoFmt;
    procedure TestInfoVal;
    procedure TestWarning;
    procedure TestWarning1;
    procedure TestWarningFmt;
    procedure TestWarningVal;
    procedure TestError;
    procedure TestError1;
    procedure TestErrorFmt;
    procedure TestErrorVal;
    procedure TestFatal;
    procedure TestFatal1;
    procedure TestFatalFmt;
    procedure TestFatalVal;
  end;

  // Test methods for class TMetaLogger

  TestTMetaLogger = class (TInterfaceTestCase<IMetaLogger>)
  strict private
    FOutput : TTestTextOutput;
  private
    procedure CheckWasOutput;
  protected
    procedure DoSetUp; override;
    procedure DoTearDown; override;
    function  MakeSUT : IMetaLogger; override;
  published
    procedure TestEnabled;
    procedure TestEnterSection;
    procedure TestEnterSection1;
    procedure TestEnterSectionFmt;
    procedure TestEnterSectionVal;
    procedure TestLeaveSection;
    procedure TestLeaveSection1;
    procedure TestLeaveSectionFmt;
    procedure TestLeaveSectionVal;
    procedure TestEnterMethod;
    procedure TestEnterMethod1;
    procedure TestLeaveMethod;
    procedure TestLeaveMethod1;
    procedure TestLog;
    procedure TestLog1;
    procedure TestLogFmt;
    procedure TestLogVal;
    procedure TestDebug;
    procedure TestDebug1;
    procedure TestDebugFmt;
    procedure TestDebugVal;
    procedure TestInfo;
    procedure TestInfo1;
    procedure TestInfoFmt;
    procedure TestInfoVal;
    procedure TestWarning;
    procedure TestWarning1;
    procedure TestWarningFmt;
    procedure TestWarningVal;
    procedure TestError;
    procedure TestError1;
    procedure TestErrorFmt;
    procedure TestErrorVal;
    procedure TestFatal;
    procedure TestFatal1;
    procedure TestFatalFmt;
    procedure TestFatalVal;
  end;

  // Test methods for class TPlainTextOutput

  TestTPlainTextOutput = class (TInterfaceTestCase<ILogOutput>)
  protected
    function  MakeSUT : ILogOutput; override;
  published
    procedure TestBeginSection;
    procedure TestEndSection;
    procedure TestWriteMessage;
  end;

implementation

uses
  System.SysUtils,
  FIToolkit.Logger.Utils, FIToolkit.Logger.Consts;

{ TTestTextOutput }

procedure TTestTextOutput.WriteLine(const S : String);
begin
  FLastWrittenLine := S;
  Inc(FWrittenLinesCount);
end;

{ TMethodHolderRec }

function TMethodHolderRec.FuncMethod(const StrParam : String; IntParam : Integer; out ObjParam : TObject) : TTypeKind;
begin
  Result := Default(TTypeKind);
end;

procedure TMethodHolderRec.ProcMethod(const StrParam : String; IntParam : Integer; out ObjParam : TObject);
begin
  {NOP}
end;

{ TestTLogger }

procedure TestTLogger.DoSetUp;
begin
  FOutput := TTestTextOutput.Create;
  SUT.AddOutput(FOutput);
end;

procedure TestTLogger.DoTearDown;
begin
  FOutput := nil;
end;

function TestTLogger.MakeSUT : ILogger;
begin
  Result := TLogger.Create;
end;

procedure TestTLogger.TestAddOutput;
const
  STR_MSG = '<TestAddOutput>';
var
  LogOutput : ILogOutput;
begin
  LogOutput := TTestTextOutput.Create;

  SUT.AddOutput(LogOutput);
  SUT.Debug(STR_MSG);

  with LogOutput as TTestTextOutput do
  begin
    CheckEquals(1, WrittenLinesCount, 'WrittenLinesCount = 1');
    CheckTrue(LastWrittenLine.Contains(STR_MSG), 'LastWrittenLine.Contains(STR_MSG)');
  end;
end;

procedure TestTLogger.TestAllowedItems;
const
  STR_MSG = '<TestAllowedItems>';
begin
  CheckEquals<TLogItems>([liMessage, liSection], SUT.AllowedItems, 'AllowedItems = [liMessage, liSection]');

  SUT.AllowedItems := [];
  SUT.EnterSection(STR_MSG);
  SUT.EnterMethod(ClassType, @TestTLogger.TestAllowedItems, []);
  SUT.Debug(STR_MSG);
  CheckEquals(0, FOutput.WrittenLinesCount, 'WrittenLinesCount = 0');

  SUT.AllowedItems := [liMessage];
  SUT.Debug(STR_MSG);
  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');

  SUT.AllowedItems := [liSection];
  SUT.EnterSection(STR_MSG);
  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');

  SUT.AllowedItems := [liMethod];
  SUT.EnterMethod(ClassType, @TestTLogger.TestAllowedItems, []);
  CheckEquals(3, FOutput.WrittenLinesCount, 'WrittenLinesCount = 3');
end;

procedure TestTLogger.TestEnterSection;
const
  STR_MSG = '<TestEnterSection>';
begin
  SUT.EnterSection(STR_MSG);

  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_MSG), 'CheckTrue::LastWrittenLine.Contains(STR_MSG)');
end;

procedure TestTLogger.TestEnterSection1;
const
  STR_VAL = String('<TestEnterSection1>');
  INT_VAL = Integer(777);
begin
  SUT.EnterSection([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestEnterSectionFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestEnterSectionFmt>');
  INT_VAL = Integer(777);
begin
  SUT.EnterSectionFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestEnterSectionVal;
const
  STR_VAL = String('<TestEnterSectionVal>');
  INT_VAL = Integer(777);
begin
  SUT.EnterSectionVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestLeaveSection;
const
  STR_MSG = '<TestLeaveSection>';
begin
  SUT.LeaveSection(STR_MSG);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#1>');
  CheckEquals(0, FOutput.WrittenLinesCount, 'WrittenLinesCount = 0');

  SUT.EnterSection(STR_MSG);
  SUT.LeaveSection(STR_MSG);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#2>');
  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_MSG), 'CheckTrue::LastWrittenLine.Contains(STR_MSG)');
end;

procedure TestTLogger.TestLeaveSection1;
const
  STR_VAL = String('<TestLeaveSection1>');
  INT_VAL = Integer(777);
begin
  SUT.LeaveSection([STR_VAL, INT_VAL]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#1>');
  CheckEquals(0, FOutput.WrittenLinesCount, 'WrittenLinesCount = 0');

  SUT.EnterSection([STR_VAL, INT_VAL]);
  SUT.LeaveSection([STR_VAL, INT_VAL]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#2>');
  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestLeaveSectionFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestLeaveSectionFmt>');
  INT_VAL = Integer(777);
begin
  SUT.LeaveSectionFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#1>');
  CheckEquals(0, FOutput.WrittenLinesCount, 'WrittenLinesCount = 0');

  SUT.EnterSectionFmt(FMT_MSG, [STR_VAL, INT_VAL]);
  SUT.LeaveSectionFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#2>');
  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestLeaveSectionVal;
const
  STR_VAL = String('<TestLeaveSectionVal>');
  INT_VAL = Integer(777);
begin
  SUT.LeaveSectionVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#1>');
  CheckEquals(0, FOutput.WrittenLinesCount, 'WrittenLinesCount = 0');

  SUT.EnterSectionVal([STR_VAL, INT_VAL, Self]);
  SUT.LeaveSectionVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(0, FOutput.SectionLevel, '(SectionLevel = 0)::<#2>');
  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestEnabled;
begin
  CheckTrue(SUT.Enabled, 'CheckTrue::Enabled<after set up>');

  SUT.SeverityThreshold := SEVERITY_NONE;
  CheckFalse(SUT.Enabled, 'CheckFalse::Enabled<after SEVERITY_NONE>');

  SUT.SeverityThreshold := SEVERITY_MAX;
  CheckTrue(SUT.Enabled, 'CheckTrue::Enabled<after SEVERITY_MAX');
end;

procedure TestTLogger.TestEnterMethod;
const
  STR_VAL = String('<TestEnterMethod>');
  INT_VAL = Integer(777);
begin
  SUT.AllowedItems := SUT.AllowedItems + [liMethod];

  { Case #1 }

  SUT.EnterMethod(TMethodHolderObj, @TMethodHolderObj.ProcMethod, [STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.ClassName),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.ClassName)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.MethodName(@TMethodHolderObj.ProcMethod)),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.MethodName)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)<Case #1>');

  { Case #2 }

  SUT.EnterMethod(TMethodHolderObj, @TMethodHolderObj.FuncMethod, [STR_VAL, INT_VAL, Self]);

  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckEquals(2, FOutput.SectionLevel, 'SectionLevel = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.ClassName),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.ClassName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.MethodName(@TMethodHolderObj.FuncMethod)),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.MethodName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)<Case #2>');
end;

procedure TestTLogger.TestEnterMethod1;
const
  STR_VAL = String('<TestEnterMethod1>');
  INT_VAL = Integer(777);
begin
  SUT.AllowedItems := SUT.AllowedItems + [liMethod];

  { Case #1 }

  SUT.EnterMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.ProcMethod, [STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(GetTypeName(TypeInfo(TMethodHolderRec))),
    'CheckTrue::LastWrittenLine.Contains(GetTypeName)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains('ProcMethod'),
    'CheckTrue::LastWrittenLine.Contains(<MethodName>)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)<Case #1>');

  { Case #2 }

  SUT.EnterMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.FuncMethod, [STR_VAL, INT_VAL, Self]);

  CheckEquals(2, FOutput.WrittenLinesCount, 'WrittenLinesCount = 2');
  CheckEquals(2, FOutput.SectionLevel, 'SectionLevel = 2');
  CheckTrue(FOutput.LastWrittenLine.Contains(GetTypeName(TypeInfo(TMethodHolderRec))),
    'CheckTrue::LastWrittenLine.Contains(GetTypeName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains('FuncMethod'),
    'CheckTrue::LastWrittenLine.Contains(<MethodName>)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)<Case #2>');
end;

procedure TestTLogger.TestLeaveMethod;
const
  RESULT_VALUE = String('<TestLeaveMethod>');
begin
  SUT.AllowedItems := SUT.AllowedItems + [liMethod];
  SUT.EnterSection('MethodSection1');
  SUT.EnterSection('MethodSection2');

  { Case #1 }

  SUT.LeaveMethod(TMethodHolderObj, @TMethodHolderObj.ProcMethod, RESULT_VALUE);

  CheckEquals(3, FOutput.WrittenLinesCount, 'WrittenLinesCount = 3');
  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.ClassName),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.ClassName)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.MethodName(@TMethodHolderObj.ProcMethod)),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.MethodName)<Case #1>');
  CheckFalse(FOutput.LastWrittenLine.Contains(RESULT_VALUE), 'CheckFalse::LastWrittenLine.Contains(RESULT_VALUE)<Case #1>');

  { Case #2 }

  SUT.LeaveMethod(TMethodHolderObj, @TMethodHolderObj.FuncMethod, RESULT_VALUE);

  CheckEquals(4, FOutput.WrittenLinesCount, 'WrittenLinesCount = 4');
  CheckEquals(0, FOutput.SectionLevel, 'SectionLevel = 0');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.ClassName),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.ClassName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(TMethodHolderObj.MethodName(@TMethodHolderObj.FuncMethod)),
    'CheckTrue::LastWrittenLine.Contains(TMethodHolderObj.MethodName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(RESULT_VALUE), 'CheckTrue::LastWrittenLine.Contains(RESULT_VALUE)<Case #2>');
end;

procedure TestTLogger.TestLeaveMethod1;
const
  RESULT_VALUE = String('<TestLeaveMethod1>');
begin
  SUT.AllowedItems := SUT.AllowedItems + [liMethod];
  SUT.EnterSection('MethodSection1');
  SUT.EnterSection('MethodSection2');

  { Case #1 }

  SUT.LeaveMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.ProcMethod, RESULT_VALUE);

  CheckEquals(3, FOutput.WrittenLinesCount, 'WrittenLinesCount = 3');
  CheckEquals(1, FOutput.SectionLevel, 'SectionLevel = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(GetTypeName(TypeInfo(TMethodHolderRec))),
    'CheckTrue::LastWrittenLine.Contains(GetTypeName)<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains('ProcMethod'),
    'CheckTrue::LastWrittenLine.Contains(<MethodName>)<Case #1>');
  CheckFalse(FOutput.LastWrittenLine.Contains(RESULT_VALUE), 'CheckFalse::LastWrittenLine.Contains(RESULT_VALUE)<Case #1>');

  { Case #2 }

  SUT.LeaveMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.FuncMethod, RESULT_VALUE);

  CheckEquals(4, FOutput.WrittenLinesCount, 'WrittenLinesCount = 4');
  CheckEquals(0, FOutput.SectionLevel, 'SectionLevel = 0');
  CheckTrue(FOutput.LastWrittenLine.Contains(GetTypeName(TypeInfo(TMethodHolderRec))),
    'CheckTrue::LastWrittenLine.Contains(GetTypeName)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains('FuncMethod'),
    'CheckTrue::LastWrittenLine.Contains(<MethodName>)<Case #2>');
  CheckTrue(FOutput.LastWrittenLine.Contains(RESULT_VALUE), 'CheckTrue::LastWrittenLine.Contains(RESULT_VALUE)<Case #2>');
end;

procedure TestTLogger.TestLog;
var
  Msg: string;
  Severity: TLogMsgSeverity;
begin
  Msg := 'TestLog';
  Severity := SEVERITY_MIN;

  { Case #1 }

  SUT.Log(Severity, Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');

  { Case #2 }

  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.Log(Severity, Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #2>');

  { Case #3 }

  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.Log(Severity, Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #3>');
end;

procedure TestTLogger.TestLog1;
const
  STR_VAL = String('<TestLog1>');
  INT_VAL = Integer(777);
var
  Severity: TLogMsgSeverity;
begin
  Severity := SEVERITY_MIN;

  { Case #1 }

  SUT.Log(Severity, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');

  { Case #2 }

  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.Log(Severity, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #2>');

  { Case #3 }

  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.Log(Severity, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #3>');
end;

procedure TestTLogger.TestLogFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestLogFmt>');
  INT_VAL = Integer(777);
var
  Msg: String;
  Severity: TLogMsgSeverity;
begin
  Msg := FMT_MSG;
  Severity := SEVERITY_MIN;

  { Case #1 }

  SUT.LogFmt(Severity, Msg, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');

  { Case #2 }

  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.LogFmt(Severity, Msg, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #2>');

  { Case #3 }

  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.LogFmt(Severity, Msg, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #3>');
end;

procedure TestTLogger.TestLogVal;
const
  STR_VAL = String('<TestLogVal>');
  INT_VAL = Integer(777);
var
  Severity: TLogMsgSeverity;
begin
  Severity := SEVERITY_MIN;

  { Case #1 }

  SUT.LogVal(Severity, [STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #1>');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');

  { Case #2 }

  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.LogVal(Severity, [STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #2>');

  { Case #3 }

  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.LogVal(Severity, [STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #3>');
end;

procedure TestTLogger.TestDebug;
var
  Msg: string;
begin
  Msg := 'TestDebug';
  SUT.SeverityThreshold := SEVERITY_DEBUG;

  SUT.Debug(Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');
end;

procedure TestTLogger.TestDebug1;
const
  STR_VAL = String('<TestDebug1>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_DEBUG;

  SUT.Debug([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestDebugFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestDebugFmt>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_DEBUG;

  SUT.DebugFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestDebugVal;
const
  STR_VAL = String('<TestDebugVal>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_DEBUG;

  SUT.DebugVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestInfo;
var
  Msg: string;
begin
  Msg := 'TestInfo';
  SUT.SeverityThreshold := SEVERITY_INFO;

  SUT.Info(Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');
end;

procedure TestTLogger.TestInfo1;
const
  STR_VAL = String('<TestInfo1>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_INFO;

  SUT.Info([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestInfoFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestInfoFmt>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_INFO;

  SUT.InfoFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestInfoVal;
const
  STR_VAL = String('<TestInfoVal>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_INFO;

  SUT.InfoVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestWarning;
var
  Msg: string;
begin
  Msg := 'TestWarning';
  SUT.SeverityThreshold := SEVERITY_WARNING;

  SUT.Warning(Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');
end;

procedure TestTLogger.TestWarning1;
const
  STR_VAL = String('<TestWarning1>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_WARNING;

  SUT.Warning([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestWarningFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestWarningFmt>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_WARNING;

  SUT.WarningFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestWarningVal;
const
  STR_VAL = String('<TestWarningVal>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_WARNING;

  SUT.WarningVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestError;
var
  Msg: string;
begin
  Msg := 'TestError';
  SUT.SeverityThreshold := SEVERITY_ERROR;

  SUT.Error(Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');
end;

procedure TestTLogger.TestError1;
const
  STR_VAL = String('<TestError1>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_ERROR;

  SUT.Error([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestErrorFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestErrorFmt>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_ERROR;

  SUT.ErrorFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestErrorVal;
const
  STR_VAL = String('<TestErrorVal>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_ERROR;

  SUT.ErrorVal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

procedure TestTLogger.TestFatal;
var
  Msg: string;
begin
  Msg := 'TestFatal';
  SUT.SeverityThreshold := SEVERITY_FATAL;

  SUT.Fatal(Msg);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(Msg), 'CheckTrue::LastWrittenLine.Contains(Msg)');
end;

procedure TestTLogger.TestFatal1;
const
  STR_VAL = String('<TestFatal1>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_FATAL;

  SUT.Fatal([STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestFatalFmt;
const
  FMT_MSG = 'Message with string arg "%s" and integer arg "%d".';
  STR_VAL = String('<TestFatalFmt>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_FATAL;

  SUT.FatalFmt(FMT_MSG, [STR_VAL, INT_VAL]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
end;

procedure TestTLogger.TestFatalVal;
const
  STR_VAL = String('<TestFatalVal>');
  INT_VAL = Integer(777);
begin
  SUT.SeverityThreshold := SEVERITY_FATAL;

  SUT.Fatal([STR_VAL, INT_VAL, Self]);

  CheckEquals(1, FOutput.WrittenLinesCount, 'WrittenLinesCount = 1');
  CheckTrue(FOutput.LastWrittenLine.Contains(STR_VAL), 'CheckTrue::LastWrittenLine.Contains(STR_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(INT_VAL.ToString), 'CheckTrue::LastWrittenLine.Contains(INT_VAL)');
  CheckTrue(FOutput.LastWrittenLine.Contains(Self.ToString), 'CheckTrue::LastWrittenLine.Contains(Self)');
end;

{ TestTMetaLogger }

procedure TestTMetaLogger.CheckWasOutput;
begin
  CheckTrue(FOutput.WrittenLinesCount > 0, 'CheckTrue::(WrittenLinesCount > 0)');
end;

procedure TestTMetaLogger.DoSetUp;
var
  Logger : ILogger;
begin
  FOutput := TTestTextOutput.Create;
  Logger := SUT.AddLogger(TLogger.Create);
  Logger.AddOutput(FOutput);
  Logger.AllowedItems := [liMessage, liSection, liMethod];
end;

procedure TestTMetaLogger.DoTearDown;
begin
  FOutput := nil;
end;

function TestTMetaLogger.MakeSUT : IMetaLogger;
begin
  Result := TMetaLogger.Create;
end;

procedure TestTMetaLogger.TestDebug;
begin
  SUT.Debug('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestDebug1;
begin
  SUT.Debug([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestDebugFmt;
begin
  SUT.DebugFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestDebugVal;
begin
  SUT.DebugVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnabled;
var
  LocalSUT : IMetaLogger;
begin
  CheckTrue(SUT.Enabled, 'CheckTrue::SUT.Enabled');

  LocalSUT := TMetaLogger.Create;
  CheckFalse(LocalSUT.Enabled, 'CheckFalse::LocalSUT.Enabled');
end;

procedure TestTMetaLogger.TestEnterMethod;
begin
  SUT.EnterMethod(TMethodHolderObj, @TMethodHolderObj.ProcMethod, []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnterMethod1;
begin
  SUT.EnterMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.ProcMethod, []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnterSection;
begin
  SUT.EnterSection('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnterSection1;
begin
  SUT.EnterSection([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnterSectionFmt;
begin
  SUT.EnterSectionFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestEnterSectionVal;
begin
  SUT.EnterSectionVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestError;
begin
  SUT.Error('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestError1;
begin
  SUT.Error([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestErrorFmt;
begin
  SUT.ErrorFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestErrorVal;
begin
  SUT.ErrorVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestFatal;
begin
  SUT.Fatal('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestFatal1;
begin
  SUT.Fatal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestFatalFmt;
begin
  SUT.FatalFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestFatalVal;
begin
  SUT.FatalVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestInfo;
begin
  SUT.Info('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestInfo1;
begin
  SUT.Info([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestInfoFmt;
begin
  SUT.InfoFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestInfoVal;
begin
  SUT.InfoVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveMethod;
begin
  SUT.EnterMethod(TMethodHolderObj, @TMethodHolderObj.ProcMethod, []);
  SUT.LeaveMethod(TMethodHolderObj, @TMethodHolderObj.ProcMethod, TValue.Empty);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveMethod1;
begin
  SUT.EnterMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.ProcMethod, []);
  SUT.LeaveMethod(TypeInfo(TMethodHolderRec), @TMethodHolderRec.ProcMethod, TValue.Empty);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveSection;
begin
  SUT.EnterSection('');
  SUT.LeaveSection('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveSection1;
begin
  SUT.EnterSection([]);
  SUT.LeaveSection([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveSectionFmt;
begin
  SUT.EnterSectionFmt('', []);
  SUT.LeaveSectionFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLeaveSectionVal;
begin
  SUT.EnterSectionVal([]);
  SUT.LeaveSectionVal([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLog;
begin
  SUT.Log(SEVERITY_MAX, '');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLog1;
begin
  SUT.Log(SEVERITY_MAX, []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLogFmt;
begin
  SUT.LogFmt(SEVERITY_MAX, '', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestLogVal;
begin
  SUT.LogVal(SEVERITY_MAX, []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestWarning;
begin
  SUT.Warning('');
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestWarning1;
begin
  SUT.Warning([]);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestWarningFmt;
begin
  SUT.WarningFmt('', []);
  CheckWasOutput;
end;

procedure TestTMetaLogger.TestWarningVal;
begin
  SUT.WarningVal([]);
  CheckWasOutput;
end;

{ TestTPlainTextOutput }

function TestTPlainTextOutput.MakeSUT : ILogOutput;
begin
  Result := TTestTextOutput.Create;
end;

procedure TestTPlainTextOutput.TestBeginSection;
var
  Msg : String;
  Instant : TLogTimestamp;

  procedure RunLocalChecks;
  begin
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMainThreadName),
      'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMainThreadName]);
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOSectionBeginningPrefix),
      'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOSectionBeginningPrefix]);

    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(Msg),
      'CheckTrue::LastWrittenLine.Contains(%s)', [Msg]);
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(DateTimeToStr(Instant)),
      'CheckTrue::LastWrittenLine.Contains(%s)', [DateTimeToStr(Instant)]);
  end;

begin
  CheckEquals(0, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 0');
  CheckEquals(0, SUTAsClass<TTestTextOutput>.WrittenLinesCount, 'WrittenLinesCount = 0');
  CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.IsEmpty, 'CheckTrue::LastWrittenLine.IsEmpty');

  Msg := 'BeginSection1';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.BeginSection(Instant, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 1');
  RunLocalChecks;

  Msg := 'BeginSection2';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.BeginSection(Instant, Msg);

  CheckEquals(2, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 2');
  RunLocalChecks;

  Msg := 'BeginSection3';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.BeginSection(Instant, Msg);

  CheckEquals(3, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 3');
  RunLocalChecks;

  CheckEquals(3, SUTAsClass<TTestTextOutput>.WrittenLinesCount, 'WrittenLinesCount = 3');
end;

procedure TestTPlainTextOutput.TestEndSection;
var
  Msg : String;
  Instant : TLogTimestamp;

  procedure RunLocalChecks;
  begin
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMainThreadName),
      'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMainThreadName]);
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOSectionEndingPrefix),
      'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOSectionEndingPrefix]);

    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(Msg),
      'CheckTrue::LastWrittenLine.Contains(%s)', [Msg]);
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(DateTimeToStr(Instant)),
      'CheckTrue::LastWrittenLine.Contains(%s)', [DateTimeToStr(Instant)]);
  end;

begin
  SUT.BeginSection(Now, 'BeginSection1');
  SUT.BeginSection(Now, 'BeginSection2');
  SUT.BeginSection(Now, 'BeginSection3');

  Assert(SUTAsClass<TTestTextOutput>.SectionLevel = 3, 'SectionLevel <> 3');
  Assert(SUTAsClass<TTestTextOutput>.WrittenLinesCount = 3, 'WrittenLinesCount <> 3');

  Msg := 'EndSection3';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_MAX;
  SUT.EndSection(Instant, Msg);

  CheckEquals(2, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 2');
  RunLocalChecks;

  Msg := 'EndSection2';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.EndSection(Instant, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 1');
  RunLocalChecks;

  Msg := 'EndSection1';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.EndSection(Instant, Msg);

  CheckEquals(0, SUTAsClass<TTestTextOutput>.SectionLevel, 'SectionLevel = 0');
  RunLocalChecks;

  CheckEquals(6, SUTAsClass<TTestTextOutput>.WrittenLinesCount, 'WrittenLinesCount = 6');
end;

procedure TestTPlainTextOutput.TestWriteMessage;
var
  Msg : String;
  Severity : TLogMsgSeverity;
  Instant : TLogTimestamp;

  procedure RunLocalChecks;
  begin
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMainThreadName),
      'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMainThreadName]);

    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(Msg),
      'CheckTrue::LastWrittenLine.Contains(%s)', [Msg]);
    CheckTrue((Severity in [SEVERITY_NONE, SEVERITY_MIN]) or
      SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(
      SUTAsClass<TTestTextOutput>.GetSeverityDescriptions[InferLogMsgType(Severity)]),
      'CheckTrue::LastWrittenLine.Contains(<SeverityDesc>)');
    CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(DateTimeToStr(Instant)),
      'CheckTrue::LastWrittenLine.Contains(%s)', [DateTimeToStr(Instant)]);

    case InferLogMsgType(Severity) of
      lmNone:
        begin {NOP} end;
      lmDebug:
        CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMsgTypeDescDebug),
          'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMsgTypeDescDebug]);
      lmInfo:
        CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMsgTypeDescInfo),
          'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMsgTypeDescInfo]);
      lmWarning:
        CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMsgTypeDescWarning),
          'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMsgTypeDescWarning]);
      lmError:
        CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMsgTypeDescError),
          'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMsgTypeDescError]);
      lmFatal:
        CheckTrue(SUTAsClass<TTestTextOutput>.LastWrittenLine.Contains(RSPTOMsgTypeDescFatal),
          'CheckTrue::LastWrittenLine.Contains(%s)', [RSPTOMsgTypeDescFatal]);
    else
      Fail('Unhandled log message type.');
    end;
  end;

begin
  { Case #1 }

  Msg := 'Message1';
  Instant := Now;
  Severity := SUT.SeverityThreshold;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #1>');
  RunLocalChecks;

  { Case #2 }

  Msg := 'Message2';
  Instant := Now;
  Severity := SEVERITY_NONE;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #2>');

  { Case #3 }

  Msg := 'Message3';
  Instant := Now;
  Severity := SEVERITY_MAX;
  SUT.SeverityThreshold := SEVERITY_NONE;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #3>');

  { Case #4 }

  Msg := 'Message4';
  Instant := Now;
  SUT.SeverityThreshold := SEVERITY_MAX;
  Severity := Pred(SUT.SeverityThreshold);
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(1, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 1)::<Case #4>');

  { Case #5 }

  Msg := 'Message5';
  Instant := Now;
  Severity := SEVERITY_DEBUG;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(2, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 2)::<Case #5>');
  RunLocalChecks;

  { Case #6 }

  Msg := 'Message6';
  Instant := Now;
  Severity := SEVERITY_INFO;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(3, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 3)::<Case #6>');
  RunLocalChecks;

  { Case #7 }

  Msg := 'Message7';
  Instant := Now;
  Severity := SEVERITY_WARNING;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(4, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 4)::<Case #7>');
  RunLocalChecks;

  { Case #8 }

  Msg := 'Message8';
  Instant := Now;
  Severity := SEVERITY_ERROR;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(5, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 5)::<Case #8>');
  RunLocalChecks;

  { Case #9 }

  Msg := 'Message9';
  Instant := Now;
  Severity := SEVERITY_FATAL;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(6, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 6)::<Case #9>');
  RunLocalChecks;

  { Case #10 }

  Msg := 'Message10';
  Instant := Now;
  Severity := SEVERITY_MAX;
  SUT.SeverityThreshold := SEVERITY_MIN;
  SUT.WriteMessage(Instant, Severity, Msg);

  CheckEquals(7, SUTAsClass<TTestTextOutput>.WrittenLinesCount, '(WrittenLinesCount = 7)::<Case #10>');
  RunLocalChecks;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTLogger.Suite);
  RegisterTest(TestTMetaLogger.Suite);
  RegisterTest(TestTPlainTextOutput.Suite);
end.
