unit Test_FIToolkit.CommandLine.Options;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  FIToolkit.CommandLine.Options, FIToolkit.CommandLine.Types, FIToolkit.CommandLine.Consts;

type
  // Test methods for class TCLIOption

  TestTCLIOption = class (TGenericTestCase)
  private
    const
      STR_PREFIX = '/';
      STR_OPTION_NAME = 'ParamName';
      STR_DELIMITER = ':';
      STR_OPTION_VALUE = 'ParamValue';
      STR_OPTION_VALUE_WITH_SPACE = 'Param' + TCLIOptionString.CHR_SPACE + 'Value';

      STR_OPTION = STR_PREFIX + STR_OPTION_NAME + STR_DELIMITER + STR_OPTION_VALUE;
      STR_OPTION_WITH_SPACE = STR_PREFIX + STR_OPTION_NAME + STR_DELIMITER + STR_OPTION_VALUE_WITH_SPACE;
  strict private
    FCLIOption : TCLIOption;
  published
    procedure TestCreateLong;
    procedure TestCreateShort;
    procedure TestHasDelimiter;
    procedure TestHasNonEmptyValue;
    procedure TestHasPrefix;
    procedure TestIsEmpty;
    procedure TestImplicitFromString;
    procedure TestImplicitToString;
    procedure TestToString;
    procedure TestValueContainsSpaces;
  end;

  // Test methods for class TCLIOptions

  TestTCLIOptions = class (TGenericTestCase)
  private
    const
      STR_OPTION1_NAME = 'Param1';
      STR_OPTION1_VALUE = 'Value1';
      STR_OPTION1 = STR_CLI_OPTION_PREFIX + STR_OPTION1_NAME + STR_CLI_OPTION_DELIMITER + STR_OPTION1_VALUE;

      STR_OPTION2_NAME = 'Param 2';
      STR_OPTION2_VALUE = 'Value 2';
      STR_OPTION2 = STR_CLI_OPTION_PREFIX + STR_OPTION2_NAME + STR_CLI_OPTION_DELIMITER + STR_OPTION2_VALUE;
  strict private
    FCLIOptions : TCLIOptions;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAddUnique;
    procedure TestContains;
    procedure TestFind;
  end;

implementation

uses
  System.SysUtils,
  TestUtils,
  FIToolkit.CommandLine.Exceptions;

procedure TestTCLIOption.TestCreateLong;
begin
  CheckException(
    procedure
    begin
      TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER);
    end,
    nil,
    'CheckException::nil'
  );

  CheckException(
    procedure
    begin
      TCLIOption.Create(String.Empty, STR_PREFIX, STR_DELIMITER);
    end,
    ECLIOptionIsEmpty,
    'CheckException::ECLIOptionIsEmpty'
  );

  CheckException(
    procedure
    begin
      TCLIOption.Create(STR_PREFIX + STR_DELIMITER, STR_PREFIX, STR_DELIMITER);
    end,
    ECLIOptionHasNoName,
    'CheckException::ECLIOptionHasNoName'
  );
end;

procedure TestTCLIOption.TestCreateShort;
begin
  CheckException(
    procedure
    begin
      TCLIOption.Create(STR_OPTION_NAME);
    end,
    nil,
    'CheckException::nil'
  );

  CheckException(
    procedure
    begin
      TCLIOption.Create(String.Empty);
    end,
    ECLIOptionIsEmpty,
    'CheckException::ECLIOptionIsEmpty'
  );

  CheckException(
    procedure
    begin
      TCLIOption.Create(STR_CLI_OPTION_PREFIX + STR_CLI_OPTION_DELIMITER);
    end,
    ECLIOptionHasNoName,
    'CheckException::ECLIOptionHasNoName'
  );
end;

procedure TestTCLIOption.TestHasDelimiter;
begin
  CheckTrue(TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER).HasDelimiter, 'CheckTrue::<Prefix → Delimiter>');
  CheckFalse(TCLIOption.Create(STR_OPTION, STR_DELIMITER, STR_PREFIX).HasDelimiter, 'CheckFalse::<Delimiter → Prefix>');
end;

procedure TestTCLIOption.TestHasNonEmptyValue;
begin
  CheckTrue(TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER).HasNonEmptyValue,
    'CheckTrue::(%s)', [STR_OPTION]);
  CheckFalse(TCLIOption.Create(STR_OPTION_NAME, STR_PREFIX, STR_DELIMITER).HasNonEmptyValue,
    'CheckFalse::(%s)', [STR_OPTION_NAME]);
end;

procedure TestTCLIOption.TestHasPrefix;
begin
  CheckTrue(TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER).HasPrefix, 'CheckTrue::<Prefix → Delimiter>');
  CheckFalse(TCLIOption.Create(STR_OPTION, STR_DELIMITER, STR_PREFIX).HasPrefix, 'CheckFalse::<Delimiter → Prefix>');
end;

procedure TestTCLIOption.TestImplicitFromString;
var
  S : String;
begin
  S := STR_OPTION;
  FCLIOption := S;

  CheckEquals(STR_OPTION, FCLIOption.OptionString, 'FCLIOption.OptionString = STR_OPTION');
end;

procedure TestTCLIOption.TestImplicitToString;
var
  S : String;
begin
  FCLIOption := TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER);
  S := FCLIOption;

  CheckEquals(STR_OPTION, S, 'S = STR_OPTION');
end;

procedure TestTCLIOption.TestIsEmpty;
var
  Option : TCLIOption;
begin
  CheckTrue(Option.IsEmpty, 'CheckTrue::<before construction>');
  Option := TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER);
  CheckFalse(Option.IsEmpty, 'CheckFalse::<after construction>');
end;

procedure TestTCLIOption.TestToString;
begin
  FCLIOption := TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER);
  CheckEquals(STR_OPTION, FCLIOption.ToString, '(FCLIOption.ToString = STR_OPTION)::<Prefix → Delimiter>');

  FCLIOption := TCLIOption.Create(STR_OPTION, STR_DELIMITER, STR_PREFIX);
  CheckEquals(STR_OPTION, FCLIOption.Name, '(FCLIOption.Name = STR_OPTION)::<Delimiter → Prefix>');
  CheckEquals(STR_OPTION, FCLIOption.ToString, '(FCLIOption.ToString = STR_OPTION)::<Delimiter → Prefix>');

  FCLIOption := TCLIOption.Create(STR_OPTION_NAME, ' ', ' ');
  CheckEquals(STR_OPTION_NAME, FCLIOption.ToString, 'FCLIOption.ToString = STR_OPTION_NAME');

  FCLIOption := TCLIOption.Create(STR_OPTION_WITH_SPACE, STR_PREFIX, STR_DELIMITER);
  CheckTrue(
    String(FCLIOption.ToString).EndsWith(
      TCLIOptionString.CHR_QUOTE + STR_OPTION_VALUE_WITH_SPACE + TCLIOptionString.CHR_QUOTE),
    'CheckTrue::(%)',
    [STR_OPTION_WITH_SPACE]
  );
end;

procedure TestTCLIOption.TestValueContainsSpaces;
begin
  CheckFalse(TCLIOption.Create(STR_OPTION, STR_PREFIX, STR_DELIMITER).ValueContainsSpaces,
    'CheckFalse::(%s)', [STR_OPTION]);
  CheckTrue(TCLIOption.Create(STR_OPTION_WITH_SPACE, STR_PREFIX, STR_DELIMITER).ValueContainsSpaces,
    'CheckTrue::(%s)', [STR_OPTION_WITH_SPACE]);
end;

{ TestTCLIOptions }

procedure TestTCLIOptions.SetUp;
begin
  FCLIOptions := TCLIOptions.Create;
  FCLIOptions.Add(STR_OPTION1);
  FCLIOptions.Add(STR_OPTION2);
end;

procedure TestTCLIOptions.TearDown;
begin
  FreeAndNil(FCLIOptions);
end;

procedure TestTCLIOptions.TestAddUnique;
const
  STR_OPTION3 = '--Param3=Value3';
var
  iOldCount, iIdx : Integer;
begin
  iOldCount := FCLIOptions.Count;
  iIdx := FCLIOptions.AddUnique(STR_OPTION3, True);
  CheckEquals(iOldCount + 1, FCLIOptions.Count,
    '(FCLIOptions.Count = iOldCount + 1)::AddUnique(STR_OPTION3, True)');

  iOldCount := FCLIOptions.Count;
  CheckEquals(iIdx, FCLIOptions.AddUnique(STR_OPTION3, False), 'AddUnique(STR_OPTION3, False) = iIdx');
  CheckEquals(iIdx, FCLIOptions.AddUnique(STR_OPTION3, True), 'AddUnique(STR_OPTION3, True) = iIdx');
  CheckEquals(iOldCount, FCLIOptions.Count,
    '(FCLIOptions.Count = iOldCount)::AddUnique(STR_OPTION3, <True/False>)');

  iOldCount := FCLIOptions.Count;
  FCLIOptions.AddUnique(AnsiUpperCase(STR_OPTION3), False);
  CheckEquals(iOldCount + 1, FCLIOptions.Count,
    '(FCLIOptions.Count = iOldCount + 1)::AddUnique(AnsiUpperCase(STR_OPTION3), False)');

  iOldCount := FCLIOptions.Count;
  CheckEquals(iIdx, FCLIOptions.AddUnique(AnsiLowerCase(STR_OPTION3), True),
    'AddUnique(AnsiLowerCase(STR_OPTION3), True) = iIdx');
  CheckEquals(iOldCount, FCLIOptions.Count,
    '(FCLIOptions.Count = iOldCount)::AddUnique(AnsiLowerCase(STR_OPTION3), True)');
end;

procedure TestTCLIOptions.TestContains;
begin
  CheckTrue(FCLIOptions.Contains(STR_OPTION1_NAME, True),
    'CheckTrue::<case insensitive (%s vs %s)>', [STR_OPTION1_NAME, STR_OPTION1]);
  CheckTrue(FCLIOptions.Contains(STR_OPTION2_NAME, True),
    'CheckTrue::<case insensitive (%s vs %s)>', [STR_OPTION2_NAME, STR_OPTION2]);

  CheckTrue(FCLIOptions.Contains(STR_OPTION1_NAME, False),
    'CheckTrue::<case sensitive (%s vs %s)>', [STR_OPTION1_NAME, STR_OPTION1]);
  CheckFalse(FCLIOptions.Contains(String(STR_OPTION2_NAME).ToLower, False),
    'CheckFalse::<case sensitive (%s vs %s)>', [STR_OPTION2_NAME, STR_OPTION2]);
end;

procedure TestTCLIOptions.TestFind;
var
  Opt : TCLIOption;
begin
  CheckTrue(FCLIOptions.Find(STR_OPTION1_NAME, Opt, True),
    'CheckTrue::<case insensitive (%s vs %s)>', [STR_OPTION1_NAME, STR_OPTION1]);
  CheckEquals(STR_OPTION1_NAME, Opt.Name, '(Opt.Name = STR_OPTION1_NAME)::<case insensitive>');

  CheckTrue(FCLIOptions.Find(STR_OPTION2_NAME, Opt, True),
    'CheckTrue::<case insensitive (%s vs %s)>', [STR_OPTION2_NAME, STR_OPTION2]);
  CheckEquals(STR_OPTION2_NAME, Opt.Name, '(Opt.Name = STR_OPTION2_NAME)::<case insensitive>');

  CheckTrue(FCLIOptions.Find(STR_OPTION1_NAME, Opt, False),
    'CheckTrue::<case sensitive (%s vs %s)>', [STR_OPTION1_NAME, STR_OPTION1]);
  CheckEquals(STR_OPTION1_NAME, Opt.Name, '(Opt.Name = STR_OPTION1_NAME)::<case sensitive>');
  CheckFalse(FCLIOptions.Find(String(STR_OPTION2_NAME).ToLower, Opt, False),
    'CheckFalse::<case sensitive (%s vs %s)>', [STR_OPTION2_NAME, STR_OPTION2]);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTCLIOption.Suite);
  RegisterTest(TestTCLIOptions.Suite);

end.
