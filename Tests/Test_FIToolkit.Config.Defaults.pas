unit Test_FIToolkit.Config.Defaults;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, FIToolkit.Config.Defaults, System.Generics.Collections,
  System.Rtti, FIToolkit.Config.Types, System.SysUtils;

type
  // Test methods for class TDefaultValueAttribute

  TestTDefaultValueAttribute = class(TTestCase)
  strict private
    FDefaultValueAttribute: TDefaultValueAttribute;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestIsEmpty;
  end;

  // Test methods for class TDefaultValueAttribute<T>

  TestTDefaultValueAttributeT = class(TTestCase)
  strict private
    type
      TTestAttribute = class (TDefaultValueAttribute<Integer>);
    const
      INT_ATTR_VALUE = 777;
  strict private
    FAttrWithNoValue,
    FAttrWithValue : TTestAttribute;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAttributeWithNoValue;
    procedure TestAttributeWithValue;
  end;

  // Test methods for class TDefaultsMap

  TestTDefaultsMap = class(TTestCase)
  strict private
    FDefaultsMap1,
    FDefaultsMap2 : TDefaultsMap;
  private
    type
      TTestAttributeBase = class abstract (TDefaultValueAttribute<Integer>);
      TTestAddAttr = class (TTestAttributeBase);
      TTestGetAttr = class (TTestAttributeBase);
      TTestHasAttr = class (TTestAttributeBase);
    const
      INT_ATTR_VALUE = 777;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAddValue;
    procedure TestGetValue;
    procedure TestHasValue;
    procedure TestIsSingleton;
  end;

implementation

uses
  TestUtils;

{ TestTDefaultValueAttribute }

procedure TestTDefaultValueAttribute.SetUp;
begin
  FDefaultValueAttribute := TDefaultValueAttribute.Create;
end;

procedure TestTDefaultValueAttribute.TearDown;
begin
  FDefaultValueAttribute.Free;
  FDefaultValueAttribute := nil;
end;

procedure TestTDefaultValueAttribute.TestIsEmpty;
  var
    bWasException : Boolean;
begin
  CheckTrue(FDefaultValueAttribute.ValueKind = dvkUndefined, 'ValueKind = dvkUndefined');

  bWasException := False;
  try
    // Value surely must be empty but we need this test to be failed if we are reaching this point:
    CheckFalse(FDefaultValueAttribute.Value.IsEmpty, 'Value.IsEmpty');
  except
    on E:Exception do
    begin
      bWasException := True;
      CheckTrue(E.InheritsFrom(EAssertionFailed), 'E.InheritsFrom(EAssertionFailed)');
    end;
  end;
  CheckTrue(bWasException, 'Value::bWasException');
end;

{ TestTDefaultValueAttributeT }

procedure TestTDefaultValueAttributeT.SetUp;
begin
  FAttrWithNoValue := TTestAttribute.Create;
  FAttrWithValue := TTestAttribute.Create(INT_ATTR_VALUE);
end;

procedure TestTDefaultValueAttributeT.TearDown;
begin
  FreeAndNil(FAttrWithNoValue);
  FreeAndNil(FAttrWithValue);
end;

procedure TestTDefaultValueAttributeT.TestAttributeWithNoValue;
begin
  CheckTrue(FAttrWithNoValue.ValueKind = dvkCalculated, 'ValueKind = dvkCalculated');
  CheckTrue(FAttrWithNoValue.Value.IsEmpty, 'Value.IsEmpty');

  RegisterDefaultValue(TTestAttribute, INT_ATTR_VALUE);

  CheckEquals(INT_ATTR_VALUE, FAttrWithNoValue.Value.AsInteger, 'Value = INT_ATTR_VALUE');
end;

procedure TestTDefaultValueAttributeT.TestAttributeWithValue;
begin
  CheckTrue(FAttrWithValue.ValueKind = dvkData, 'ValueKind = dvkData');
  CheckFalse(FAttrWithValue.Value.IsEmpty, 'Value.IsEmpty');
  CheckEquals(INT_ATTR_VALUE, FAttrWithValue.Value.AsInteger, 'Value = INT_ATTR_VALUE');
end;

{ TestTDefaultsMap }

procedure TestTDefaultsMap.SetUp;
begin
  FDefaultsMap1 := TDefaultsMap.Create;
  FDefaultsMap2 := TDefaultsMap.Create;
end;

procedure TestTDefaultsMap.TearDown;
begin
  FreeAndNil(FDefaultsMap1);
  FreeAndNil(FDefaultsMap2);
end;

procedure TestTDefaultsMap.TestAddValue;
var
  Value: TValue;
  DefValAttribClass: TDefaultValueAttributeClass;
begin
  Value := INT_ATTR_VALUE;
  DefValAttribClass := TTestAddAttr;

  TDefaultsMap.AddValue(DefValAttribClass, Value);

  CheckTrue(TDefaultsMap.HasValue(DefValAttribClass), 'HasValue');
  CheckEquals(INT_ATTR_VALUE, TDefaultsMap.GetValue(DefValAttribClass).AsInteger,
    'TDefaultsMap.GetValue = INT_ATTR_VALUE');
  CheckEquals(INT_ATTR_VALUE, FDefaultsMap1.GetValue(DefValAttribClass).AsInteger,
    'FDefaultsMap1.GetValue = INT_ATTR_VALUE');
  CheckEquals(FDefaultsMap1.GetValue(DefValAttribClass).AsInteger, FDefaultsMap2.GetValue(DefValAttribClass).AsInteger,
    'FDefaultsMap2.GetValue = FDefaultsMap1.GetValue');
end;

procedure TestTDefaultsMap.TestGetValue;
var
  ReturnValue: TValue;
  DefValAttribClass: TDefaultValueAttributeClass;
  bWasException : Boolean;
begin
  DefValAttribClass := TTestGetAttr;

  bWasException := False;
  try
    ReturnValue := TDefaultsMap.GetValue(DefValAttribClass);
  except
    on E:Exception do
    begin
      bWasException := True;
      CheckTrue(E.InheritsFrom(EListError), 'E.InheritsFrom(EListError)');
    end;
  end;
  CheckTrue(bWasException, 'GetValue::bWasException');

  TDefaultsMap.AddValue(DefValAttribClass, INT_ATTR_VALUE);
  ReturnValue := TDefaultsMap.GetValue(DefValAttribClass);

  CheckEquals(INT_ATTR_VALUE, ReturnValue.AsInteger, 'ReturnValue = INT_ATTR_VALUE');
end;

procedure TestTDefaultsMap.TestHasValue;
var
  ReturnValue: Boolean;
  DefValAttribClass: TDefaultValueAttributeClass;
begin
  DefValAttribClass := TTestHasAttr;

  ReturnValue := TDefaultsMap.HasValue(DefValAttribClass);

  CheckFalse(ReturnValue, 'ReturnValue');

  TDefaultsMap.AddValue(DefValAttribClass, INT_ATTR_VALUE);
  ReturnValue := TDefaultsMap.HasValue(DefValAttribClass);

  CheckTrue(ReturnValue, 'ReturnValue');
end;

procedure TestTDefaultsMap.TestIsSingleton;
begin
  CheckEquals(TDefaultsMap.StaticInstance, FDefaultsMap1.StaticInstance,
    'FDefaultsMap1.StaticInstance = TDefaultsMap.StaticInstance');
  CheckEquals(FDefaultsMap1.StaticInstance, FDefaultsMap2.StaticInstance,
    'FDefaultsMap2.StaticInstance = FDefaultsMap1.StaticInstance');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTDefaultValueAttribute.Suite);
  RegisterTest(TestTDefaultValueAttributeT.Suite);
  RegisterTest(TestTDefaultsMap.Suite);
end.
