unit Test_FIToolkit.Logger.Types;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  FIToolkit.Logger.Types;

type
  // Test methods for class TLogMsgTypeDescriptions

  TestTLogMsgTypeDescriptions = class(TGenericTestCase)
  strict private
    FLogMsgTypeDescriptions: TLogMsgTypeDescriptions;
  published
    procedure TestCreate;
    procedure TestItems;
    procedure TestMaxItemLength;
    procedure TestUninitialized;
  end;

implementation

uses
  System.SysUtils,
  TestUtils;

{ TestTLogMsgTypeDescriptions }

procedure TestTLogMsgTypeDescriptions.TestCreate;
const
  STR_INFO_DESC = 'INFO';
  STR_WARNING_DESC = 'WARNING';
  STR_ERROR_DESC = 'ERROR';
  INT_DUPLICATE_FACTOR = 3;
var
  arrDescs : TArray<TLogMsgTypeDescription>;
  LMT : TLogMsgType;
  iDupCycleCount, i : Integer;
begin
  { Check regular creation }

  FLogMsgTypeDescriptions := TLogMsgTypeDescriptions.Create([
    TLogMsgTypeDescription.Create(lmInfo, STR_INFO_DESC),
    TLogMsgTypeDescription.Create(lmWarning, STR_WARNING_DESC),
    TLogMsgTypeDescription.Create(lmError, STR_ERROR_DESC)
  ]);

  CheckEquals(STR_INFO_DESC, FLogMsgTypeDescriptions[lmInfo], 'Items[lmInfo] = STR_INFO_DESC');
  CheckEquals(STR_WARNING_DESC, FLogMsgTypeDescriptions[lmWarning], 'Items[lmWarning] = STR_WARNING_DESC');
  CheckEquals(STR_ERROR_DESC, FLogMsgTypeDescriptions[lmError], 'Items[lmError] = STR_ERROR_DESC');
  CheckTrue(FLogMsgTypeDescriptions[lmFatal].IsEmpty, 'CheckTrue::Items[lmFatal].IsEmpty');

  { Check creation via oversized array with duplicates }

  SetLength(arrDescs, (Ord(High(TLogMsgType)) - Ord(Low(TLogMsgType)) + 1) * INT_DUPLICATE_FACTOR);
  LMT := Low(TLogMsgType);
  iDupCycleCount := 1;
  for i := 0 to High(arrDescs) do
  begin
    arrDescs[i] := TLogMsgTypeDescription.Create(LMT, Format('ITEM_%d_DUP_%d', [Ord(LMT), iDupCycleCount]));

    if LMT <> High(TLogMsgType) then
      LMT := Succ(LMT)
    else
    begin
      Inc(iDupCycleCount);
      LMT := Low(TLogMsgType);
    end;
  end;

  FLogMsgTypeDescriptions := TLogMsgTypeDescriptions.Create(arrDescs);
  for LMT := Low(TLogMsgType) to High(TLogMsgType) do
    CheckTrue(FLogMsgTypeDescriptions[LMT].EndsWith('_DUP_' + INT_DUPLICATE_FACTOR.ToString),
      'CheckTrue::Items[LMT].EndsWith("_DUP_%d")', [INT_DUPLICATE_FACTOR]);
end;

procedure TestTLogMsgTypeDescriptions.TestItems;
var
  LMT : TLogMsgType;
  sDesc : String;
begin
  for LMT := Low(TLogMsgType) to High(TLogMsgType) do
  begin
    sDesc := 'TEST_' + Ord(LMT).ToString;
    FLogMsgTypeDescriptions[LMT] := sDesc;
    CheckEquals(sDesc, FLogMsgTypeDescriptions[LMT], 'Items[LMT] = sDesc');
  end;
end;

procedure TestTLogMsgTypeDescriptions.TestMaxItemLength;
const
  STR_SHORT_DESC  = '123';
  STR_MEDIUM_DESC = '12345';
  STR_LONG_DESC   = '1234567';
begin
  FLogMsgTypeDescriptions := TLogMsgTypeDescriptions.Create([
    TLogMsgTypeDescription.Create(lmDebug, STR_SHORT_DESC),
    TLogMsgTypeDescription.Create(lmError, STR_LONG_DESC),
    TLogMsgTypeDescription.Create(lmInfo, STR_MEDIUM_DESC)
  ]);

  CheckEquals(STR_LONG_DESC.Length, FLogMsgTypeDescriptions.MaxItemLength, 'MaxItemLength = STR_LONG_DESC.Length');
end;

procedure TestTLogMsgTypeDescriptions.TestUninitialized;
var
  LMT : TLogMsgType;
begin
  CheckEquals(0, FLogMsgTypeDescriptions.MaxItemLength, 'MaxItemLength = 0');

  for LMT := Low(TLogMsgType) to High(TLogMsgType) do
    CheckTrue(FLogMsgTypeDescriptions[LMT].IsEmpty, 'CheckTrue::Items[LMT].IsEmpty');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTLogMsgTypeDescriptions.Suite);
end.
